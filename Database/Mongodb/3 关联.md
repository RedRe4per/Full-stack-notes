### Mongodb 3 关联

1. **关联（类似于 sql）**

   在 sql 中，关联可能是1对多，其中多的部分可能是0、1、Many。Mongodb 中数据是以 array 的形式存储，因此可能是0个数据，不需考虑是否为0的情况。<font color='red'>Mangodb 中关联的主体是 collection 中的 documents。</font>

   Mongodb 的关联方式有一对一，一对多，和多对多。关联又分为嵌入式和引用式。

   1. <font color='blue'>Embedded 嵌入式</font>：直接把另外一个 document 嵌入到当前 document 中，变成它的一个 Object。

      <img src="C:\Users\GUOQING ZHU\AppData\Roaming\Typora\typora-user-images\image-20220529191632265.png" alt="image-20220529191632265" style="zoom: 80%;" />

      上面是一对一的情况。一对多的情况中，多个另外 documents 会组成一个数组，其每个元素都是对象。

      <img src="C:\Users\GUOQING ZHU\AppData\Roaming\Typora\typora-user-images\image-20220529192041327.png" alt="image-20220529192041327" style="zoom:80%;" />

      多对多的情况下会比 reference 形式更复杂。因为当需要修改被嵌入的 Object 时，由于多对多，它就对应了多个 documents，这时就需要扫描整个 collection。<font color='red'>所以在多对多时，一般使用 reference 形式。</font>

      

   2. <font color='blue'>Reference 引用式</font>：引用式是在一个 document 中，存另一个相关联 document 的 _id。一对一时：

      <img src="C:\Users\GUOQING ZHU\AppData\Roaming\Typora\typora-user-images\image-20220529191450461.png" alt="image-20220529191450461" style="zoom:80%;" />

      一对多的情况中，多个另外 documents 的 _id 会组成一个数组，每个元素是 _id。

      <img src="C:\Users\GUOQING ZHU\AppData\Roaming\Typora\typora-user-images\image-20220529192233124.png" alt="image-20220529192233124" style="zoom: 80%;" />

      多对多的情况下没什么变化，只是另外多个 documents 也用数组表示关联 documents 了。

      <img src="C:\Users\GUOQING ZHU\AppData\Roaming\Typora\typora-user-images\image-20220529193345122.png" alt="image-20220529193345122" style="zoom:80%;" />

   

2. **Reference 中的双向绑定与单向绑定**

   如果使用 document1 中（如 students），只需要知道 document2（如 address），而完全不需要知道 document2（address）中是否有哪些 document1（student），使用单向关联即可。

   但如果想从 document2 中搜索 document1 的信息，就需要双向绑定。

   

3. **Normalization 和 de-Normalization**

   de-Normalization 是复制，如 Embedded 中复制另一个文档数据，normalization 则相反。实际使用时，经常会复制另一个文档中的一小部分数据，如 address 中的 city，而不复制 address 中其他详细信息。

   这样做的好处是不需要再用 populate 形式通过关联操作 document 取数据（耗费性能），查询时间更快。但是坏处是如果对 address 进行更新，还需要再给复制的信息更新。需要权衡，考虑用户用读/写哪种操作多。

   

4. **one to millions 关系**

   单边绑定的极端例子。

   Mongodb 中单个 document 有 16mb的 上限，其他数据库中有些更小。例如有一个数据文档和一百万个传感器文档，这时不能在传感器文档中存入数据，因为占用空间太大。这时应该用数据单向绑定传感器。

   

5. **嵌入式和引用式的使用场景**

   1. 如果可以做嵌入式就尽量做，尤其是<font color='green'>一对一</font>关系的情况下。

   2. 如果是<font color='green'>一对几个</font>，可以考虑嵌入式，但是要看场景。如果认为 one to couple 中的 couple 数量不会扩张成几百个，就可以用。

   3. 如果是<font color='green'>一对上百个或更多</font>，考虑使用引用式

   4. 如果是<font color='green'>一对百万个</font>，考虑单边绑定引用式

   5. 若<font color='green'>读的要求远大于写的要求</font>，应考虑做 de-normalization，把经常读的数据多复制几分，提高查询效率。

      

6. **Indexes**

   Indexes 是索引，目的是帮助排序，查找速度更快。索引常见的两个类型是 sort 排序和 unique 唯一性。

   在默认情况下，collection 中只有 _id 索引（保证唯一性）。

   2小时10分

   

7. **Aggregation**

   Aggregation pipeline 是针对某个原始数据修改或添加，类似于 middleware，这里叫做 stage。可以筛选/添加数据，传给后面的 stage。

   Aggregation 的操作完全可以在服务器端实现，但是性能上差很多。因为数据库是专门用来操作数据的，而 Node.js 不是。因此对数据的操作应该尽量在数据库端。另外，所有数据都在服务器端操作，会传输大量数据，并且很多数据是没有用的。最好的方法就是现在数据库端操作数据，再传给服务器。

   

8. **Transaction**

   Transaction 是合并数据操作，如银行转账，添加钱和减少钱要合并在 transaction 中。它可以保证不同的数据操作同时成功或同时失败。可以后期再添加 transaction 功能。

   