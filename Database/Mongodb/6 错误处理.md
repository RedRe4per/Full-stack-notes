### Mongodb 6 错误处理

1. **方法一：try catch 包裹住 async 的请求**

   ```javascript
   async function addStudent(req, res){
       const {firstName, lastName, email} = req.body;
       const student = new Student({ firstName, lastName, email});
       try{
           await student.save();
       } catch (e){          
           console.log(e);
           return res.send(e);
       }
       res.status(201).json(student);
   }
   ```

   用于 async await 写法时捕获错误。

   

2. **方法二：用 .catch 得到 promise 的错误**

   ```javascript
   async function addStudent(req, res){
       const {firstName, lastName, email} = req.body;
       const student = new Student({ firstName, lastName, email});
       student.save().then().catch(e => {        //promise.catch
           console.log(e);
           return res.send(e);
       })
       res.status(201).json(student);
   }
   ```

   用于 promise 写法时捕获错误。

   

3. **方法三：回调函数**

   ```javascript
   async function addStudent(req, res){
       const {firstName, lastName, email} = req.body;
       const student = new Student({ firstName, lastName, email});
       student.find(error, result) => {     //回调函数，类似于promise风格
           if(error){
               console.log(e);
          	 	return res.send(e);
           }
       }
       res.status(201).json(student);
   }
   ```

   用于回调函数写法时抓取错误。

   

4. **方法选择**

   如果是自己写个新项目，就可以随便选写法，建议用 async await 写法。如果是接手现有代码，用公司当前代码的方法来写。

   

5. **实际开发时的写法（try catch 方法扩展）**

   try catch 方法是把 await 的代码包裹住。而 try catch 是可以扩展范围的，即把 route handler 整个 C/R/U/D 的 function （如 addStudeny()）包裹住，即抓 route handler 的错误。同样地，这个错误处理可以应用到所有的 route handler 中。

   下面这个写法中，函数的目的就是把被作为参数传进去的函数，做一个 try catch 的包裹，并且包裹后作为中间件注册到路径上。

   ```javascript
   function tryCatch(routeHandler){  //定义，在controllers文件中student文件夹中
       return async (req, res, next) => {  //返回一个middleware，因为要把这个中间件注册到路径上。
           try{
               await routeHandler(req, res, next);   
           } catch(e){
               next(e); //传递error对象，到错误处理中间件。
           }
       }
   }
   tryCatch(addStudent); 
   ```

   比较常见的错误一般会用 `next(e)` 传递到错误处理中间件中处理。而比较具体的错误会直接在函数内处理。例如，方法一通常和这个方法混用。常见错误用这个方法传入错误处理中间件，具体错误用方法一的写法在函数内处理。

   

6. **直接用 express-async-errors 包抓取错误**

   它进入 express 框架中进行 try catch 操作。安装：`npm i express-async-errors --save`

   这个包适用于 express@4 版本。在 express@5 版本中，官方已经内置了此功能。（p3用的 @4.18）

   这个包应导入至 index.js 文件下。

   ```javascript
   const express = require('express');
   require('express-async-errors');       //使用express包后立刻用express-async-errors包
   const User = require('./models/user');
   ...
   ```

   <font color='lightgray'>另外，`const a = require('a')` 这种写法，是因为 `a` 在文件里做了导出 exports。但是要注意的是，文件是否导出，对文件内部的代码执行是不影响的，即 `require('a')` 时 a 文件内部代码已经被执行了一遍。而 `express-async-errors` 已经在代码中对 express 对象进行了改动，不需导出。</font>

   <font color='red'>这时返回的错误是一个 express 的错误解释，很难读懂，需要进一步处理。</font>

   

   对于处理被抓取的错误，可以在 middleware 文件夹下建立 errorHandler.js 文件（Node.js@4.5 节）：

   ```javascript
   module.exports = (error, req, res, next) => {
       console.log(error);
       return res.status(500).json({
           error:'Error! Please try later',
       })
   }
   ```

   index.js 中引用 errorHandler.js，并且注册到 app 上。(写在 connectToDB 之前)

   ```javascript
   app.use(errorHandler);
   ```

   <font color='red'>这时再返回错误，就是 status code 500，返回的 JSON 内容是自定义的了。</font>因此，如何处理错误其实就是根据 errorHandler.js 中的逻辑决定。500是个托底的错误，实际应该用一系列的 if/else 或者 switch 来处理各种错误。其中的逻辑是检测错误的类型，然后处理。如：

   ```javascript
   module.exports = (error, req, res, next) => {
       if(error.name === 'validationError'){ //原始方法，因为是error中是否有name属性是未知的。
           									//要通过断点或文档来找到错误属性。
           return res.status(400).json(error);	//这里是把错误对象传给前端。但实际只需要message。
       }									//实际上开发环境返回全部信息，生产环境只需返回message。
       
       console.log(error);
       return res.status(500).json({
           error:'Error! Please try later',
       })
   }
   ```

   生产环境和开发环境兼容的写法：

   ```javascript
   module.exports = (error, req, res, next) => {
       if(error.name === 'validationError'){ 
           if(process.env.NODE_ENV === 'production'){
               return res.status(400).json({ error: error.message});	
           }
           return res.status(400).json(error);	
       }	
   ```

   更好的检测方式：

   ```javascript
   module.exports = (error, req, res, next) => {
       if(error instanceof CustomError){}
   }
   
   next(new CustomError('xxxxx'));  //抛出错误
   
   class CustomError extends Error {
       constructor(message){
           super(message);
       }
   }
   ```

   

7. **处理更多的错误**

   如果错误太多，errorHandler.js 文件就会过长。这时应该把文件拆出去。这时的结构应该是：

   |-- middleware

   ​	|-- error

   ​		|-- index.js  引入全部错误处理文件，统一导出

   ​		|-- validationErrorHandler.js   如错误是验证错误，就返回；如不是，就用 `next()` 传递到下个文件。

   ​		|-- xxxxErrorHandler.js

   这时还要在根目录的 index.js 中用 `app.use()` 引入。

   ​	