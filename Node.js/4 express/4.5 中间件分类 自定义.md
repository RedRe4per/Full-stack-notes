### Node.js 4.5 中间件的分类 自定义中间件

1. **中间件的分类**

   Express 官方把常见的中间件用法，分成了五大类：

   1. 应用级别的中间件

   2. 路由级别的中间件

   3. 错误级别的中间件

   4. Express 内置的中间件

   5. 第三方的中间件

      

2. **应用级别的中间件**

   通过 <font color='green'>`app.use()` </font>或 <font color='green'>`app.get()` </font>或 <font color='green'>`app.post()` </font>，<font color='red'>绑定到 app 实例上的中间件</font>，叫做应用级别的中间件。（即4.4节中的例子。）

   ```javascript
   app.use((req, res, next) => {
       next()
   })
   app.get('/', mw1, (req, res) => {
       res.send('Home page.')
   })
   ```

   

3. **路由级别的中间件**

   绑定到 `express.Router()` 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。区别是，应用级别的中间件时绑定到 app 实例上，路由级别中间件绑定到 router 实例上：

   ```javascript
   const app = express()
   const router = express.Router()
   
   router.use(function(req, res, next){  //路由级别的中间件
       console.log('Time: ', Date.now())
       next()
   })
   
   app.use('/', router)  //注册路由并添加前缀
   ```

   

4. **错误级别的中间件**

   错误级别中间件的作用：专门用来<font color='red'>捕获整个项目中发生的异常错误</font>，从而防止项目异常崩溃的问题。代码中错误发生时，可以直接被错误中间件捕获到（代码跳转至错误中间件），类似于 `catch()`。如果不写错误中间件，项目发生错误就会崩溃，不能继续运行。

   错误级别中间件的 function 处理函数中，<font color='red'>必须有4个形参</font>，从前到后分别是 `(err, req, res, next)`。

   <font color='red'>错误级别中间件必须注册在所有路由之后。</font>

   ```javascript
   app.get('/', (req, res) => {   //路由
       throw new Error('Error in server!')   //抛出自定义错误
       res.send('Home page.')
   })
   const middleware1 = (req, res) => {   //路由
       if token not exist {
           next(new Error('error'))   //用next()抛出错误
           return;
       } 
       next()
   })
   
   app.use(function(err, req, res, next){   //错误级别中间件
       console.log('Error happened: ' + err.message)    //在服务器打印错误信息
       res.send('Error! ' + err.message)   //向客户端响应错误信息
   })
   ```

   

   错误中间件一般会有多个，每个错误中间件负责一个类型的错误。在调用下一个错误中间件时，需要把错误以 `next()` 参数的形式继续传递下去。但是，即使有多个错误中间件，也无法保证100%抓取到了所有错误。因此要检查错误是否传递到了最后一个错误中间件中（最后一个错误中间件不处理错误，而是兜底）。如果传入了，应该返回 500 状态码（不好的选择，但是只能写 500 状态码），并且要把错误记录下来用来以后修复。

   

   <font color='blue'>怎么在 error handler 中处理错误，判定 statue code，把信息从错误对象中取出</font>

   错误不是自己写的

   ```javascript
   const errorM1 = (error, req, res, next) => {  //error通常传个对象过来，虽然可以传字符串。
       if(error.type === 'validationError'){
           res.status(400).json({error:error.message});   
       }  
   }
   ```

   错误是自己写的，用 `instanceof` 来检测。这个方法可以检测前者是否是后者的一个实例。如果前者是后者通过 `new` 构造或者 `extends` 继承的，都算作后者的实例。

   ```javascript
   const errorM1 = (error, req, res, next) => {  
       if(error instanceof CustomError){
           res.status(400).json({error:error.message});
       }  
   }
   ```

   

   <font color='blue'>注册错误中间件</font>

   全局注册在 `app.use()` 中，在 `app.listen()` 之前。

   

5. **Express 内置的中间件**

   自 Express 4.16.0 版本，Express 内置了3个常用的中间件，提高开发效率和体验：

   1. `express.static` 快速托管静态资源的内置中间件（4.2节中详细介绍），如 HTML 文件、图片、CSS 样式等，无兼容性。 

      

   2. `express.json` 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）。请求体数据可以在 postman 中生成，选择 body-raw-最右边下拉菜单选 JSON。JSON 格式的对象，属性名必须加 `" "`。

      <font color='red'>服务器中可以使用 `req.body` 属性来接收客户端发送来的请求体数据。</font>默认情况下，如果不配置解析表单数据的中间件，则 `req.body` 默认等于 undefined。

      解析后的数据会被挂载到 `req.body` 中，之后可以访问。

      ```javascript
      app.use(express.json())  //全局中间件。()中不用加参数/属性，因为是全局解析。
      ```

      

   3. `express.urlencoded` 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）。

      基本同 `express.json` 用法。postman 上选择 body-(x-www-form-urlencoded)。

      ```javascript
      app.use(express.urlencoded({ extended:false }))  //全局中间件，固定写法
      ```

      

6. **第三方的中间件**

   非 Express 官方内置的，而是由第三方开发出的中间件。在 express 4.16.0 版本前，经常使用 body-parser 第三方中间件来解析请求体数据。第三方中间件需要下载并且配置才能使用。使用步骤：

   1. 运行 `npm install 中间件包名` 来安装中间件
   2. 使用 require 导入中间件（需要路径）
   3. 调用 `app.use()` 注册并使用中间件

   

7. **自定义中间件案例**

   手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据。步骤：

   1. 定义中间件

   2. 监听 req 的 data 事件（只要触发了data事件，就证明有数据被发送给服务器）

      在中间件中，需要监听 req 对象的 data 事件来获取客户端发送到服务器的数据（用 `.on` 监听）。

      如果数据量比较大，无法一次性发送完，则客户端会<font color='red'>把数据切割后，分批发送到服务器</font>。所以 data 事件可能会触发多次，每一次触发 data 事件时，<font color='red'>获取到的数据只是完整数据的一部分</font>，需要手动对接收到的数据拼接。

      ```javascript
      let str = ''  //用来储存客户端发来的请求体数据
      req.on('data', (chunk) => {   //.on方法绑定事件。
          str += chunk  //拼接请求体数据
      })  //这里没写next()是因为它不是一个单独的中间件，而是把它和下面的end事件放在同一个中间件内部。
      ```

      

   3. 监听 req 的 end 事件（end 触发证明了数据发送完毕，服务器端已经完整接收到了表单数据）

      ```javascript
      req.on('end', () => {
      	console.log(str)
      })
      ```

      

   4. 使用 querystring 模块解析请求体数据

      ```javascript
      const qs = require('querystring')
      req.on('end', () => {
      	const body = qs.parse(str)
          next()
      })
      ```

      

   5. 将解析出来的数据对象挂载为 req.body（因为 express 用 req.body 接收客户端发来的请求体数据，这里要把原本的数据替换成新格式的数据）

      上游的中间件和下游的中间件及路由之间，共享同一份 req 和 res。因此，我们可以将解析出来的数据，挂载为 req 的自定义属性，命名 req.body，供下游使用。

      ```javascript
      const qs = require('querystring')
      req.on('end', () => {
      	const body = qs.parse(str)
          req.body = body
          next()
      })
      ```

      

   6. 将自定义中间件封装成模块

      ```javascript
      //custom-body-parser.js 模块中
      const qs = require('querystring')
      function bodyParser(req, res, next){/* 省略其他代码，其实就是前面步骤放进一个中间件中 */}
      module.exports = bodyParser   //封装成模块
      ```

      ```javascript
      const myBodyParser = require('custom-body-parser')
      app.use(myBodyParser)  //调用模块
      ```

      

8. 

